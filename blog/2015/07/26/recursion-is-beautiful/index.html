
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Recursion Is Beautiful, the Language Might Be Ugly - Common Code</title>
  <meta name="author" content="Vincent">

  
  <meta name="description" content="Introduction For better or for worse, recursion is seen as the weird cousin of loops. It
solves some problems really well, it&#39;s often elegant and &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://vandrada.github.io/blog/2015/07/26/recursion-is-beautiful/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Common Code" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Common Code</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="vandrada.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Recursion Is Beautiful, the Language Might Be Ugly</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-26T14:20:48-05:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:20 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Introduction</h2>

<p>For better or for worse, recursion is seen as the weird cousin of loops. It
solves some problems really well, it&#39;s often elegant and looks extremely simple,
yet for some reason, it doesn&#39;t get the attention that it should. I know of
many people that are out-right scared of recursion, and seeing the lengths some
people go to code Trees iteratively or use a loop and a stack only shows that
somewhere along the line, people get a bad idea about recursion. So let&#39;s do the
teen movie treatment and take off recursion&#39;s glasses and get rid of the
ponytail.</p>

<p>Like most other CS students, my first introduction to recursive programming was
the usual <code>factorial</code> function</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>At first it was mind-blowing, but after looking at it I realized it&#39;s a pretty
simple recursive function. Calling <code>factorial(5)</code> reduces to</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">factorial</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="mi">5</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
</span><span class='line'>        <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span><span class='line'>            <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</span><span class='line'>                <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>                    <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span> <span class="c1">// we hit the base case, start unwinding</span>
</span><span class='line'>                <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span>
</span><span class='line'>            <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">6</span>
</span><span class='line'>        <span class="mi">5</span> <span class="o">*</span> <span class="mi">24</span>
</span><span class='line'>    <span class="mi">120</span>
</span></code></pre></td></tr></table></div></figure>

<p>All recursive functions have a base case to stop the recursion and the general
case that reduces the problem to sub-problems. For <code>factorial</code>, the base case is
1 and the sub-problem is the factorial <code>n - 1</code>.</p>

<h2>Up Your Recursive Game</h2>

<h3>Lists</h3>

<p>After understanding the <code>factorial</code> function, the next recursive problem that
came up was recursive data structures, or data structures that are defined in
terms of themselves. The two most famous being Lists and Trees.</p>

<p>We can define a List as either <code>Nil</code> which represents an empty List, or a <code>Cons</code>
cell followed by a List. So we can have</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Cons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">Cons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">Nil</span><span class="o">))))</span>
</span></code></pre></td></tr></table></div></figure>

<p>Which we could picture with ASCII art as</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">+---+</span>    <span class="o">+---+</span>    <span class="o">+---+</span>    <span class="o">+---+</span>
</span><span class='line'><span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="o">-&gt;</span> <span class="n">Nil</span>
</span><span class='line'><span class="o">+---+</span>    <span class="o">+---+</span>    <span class="o">+---+</span>    <span class="o">+---+</span>
</span></code></pre></td></tr></table></div></figure>

<p>Lists are recursive data structures and their usual definition in Java is
similar to</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">elem</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>While the actual data structure is recursive, I was taught to treat them in an
iterative manner. Looping through the list to find the last element and adding a
new element, or looping through the whole structure to print it. Often times,
the code ending up looking something like this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">;</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// do something</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>Because of this, the recursive nature of Lists wasn&#39;t really highlighted and it
took another data structure to really drive the nature of recursive data
structures home</p>

<h3>Binary Trees</h3>

<p><a href="https://en.wikipedia.org/wiki/Binary_tree">Binary Trees</a> are also recursive
data structures that are actually treated as such. Similar to other recursive
data structures, their definition is also simple: a Binary Tree has a root which
is a node, a node has at most two children, a left child and a right child,
these children nodes are also binary trees. Here&#39;s a simple Binary Tree in
ASCII art</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">            4
        /       \
       3         5
    /     \        \
   1       2        7
</code></pre></div>
<p>This particular tree is a Binary Search Tree since each element to the left of a
node is less than the root and each element to the right is greater than the
root. In this example, not only is the tree rooted at 4 a Tree, but</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">        3
    /       \
   1         2
</code></pre></div>
<p>Is a Tree and so is</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    5
        \
         7
</code></pre></div>
<p>A simple Binary Search Tree could be implemented in Java like this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BST</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">BST</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">T</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">elem</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">insert</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">T</span> <span class="n">elem</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// the new element is less than this node&#39;s value</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">elem</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">elem</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">elem</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">insert</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// the new element is greater than this node&#39;s value</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">elem</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">elem</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">elem</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">insert</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">T</span> <span class="n">elem</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">;</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>            <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>The code is pretty simple, but it&#39;s a bit verbose. A <code>Node</code> has an element and
two children, <code>left</code> and <code>right</code>, and a <code>BST</code> has a <code>Node</code> as a root. Inserting
an element into a <code>BST</code> first checks if the root is <code>null</code> or if the Tree is
empty, if it is, we create a new node and this node becomes the root. If the
root isn&#39;t <code>null</code>, we have to check if the element to be added is less than or
greater than the root&#39;s element and insert it to the correct side accordingly.</p>

<p>Binary Search Trees made recursion really click for me, but I had one assignment
that studied two separate implementations of trees, one recursive and another
with arrays. The recursive implementation always blew the stack and the one with
the array ran out of space since most of the array is not used, leaving the
impression that recursion simply isn&#39;t a viable alternative. So aside from some
special algorithms that would be a mess if they were written iteratively, I
almost never used recursion in my day-to-day programming. Instead I stuck to
loops and thought of recursion as a cool--if a but murky--concept, but
ultimately one that was ineffective.</p>

<h2>Embracing Recursion</h2>

<p>While he was teaching us recursion, my professor made a particular remark that
stayed with me. He said something along the lines of, &quot;It&#39;s hard to think in
terms of recursion unless you program in Lisp...those people could do anything
with recursion.&quot; I looked up Lisp because I really wanted to understand
recursion and saw all the parens and quickly gave up on learning anything that
resembled Lisp. But it left me wondering why Lisp programmers would be better at
recursion than other programmers.</p>

<p>Fast-forward a year or so and there I was learning Haskell, frustrated that it
didn&#39;t have loops and thinking how anyone could get anything done with it. I
knew of <code>map</code>, <code>filter</code>, and <code>fold</code>, but thought they were novelties and that
it would be difficult to think in terms of only those three functions. When
recursion came up, I remembered the few times I used it in class and felt uneasy
using <em>only</em> recursion.</p>

<p>After seeing code for Trees in Haskell that was similar to this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Empty</span>
</span><span class='line'>
</span><span class='line'><span class="nf">insert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
</span><span class='line'><span class="nf">insert</span> <span class="kt">Empty</span> <span class="n">elem</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">elem</span> <span class="kt">Empty</span> <span class="kt">Empty</span>
</span><span class='line'><span class="nf">insert</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="n">elem</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="p">(</span><span class="n">insert</span> <span class="n">left</span> <span class="n">elem</span><span class="p">)</span> <span class="n">right</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="p">(</span><span class="n">insert</span> <span class="n">right</span> <span class="n">elem</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>I was blown away by how clear it was. First, the defintion of a <code>Tree</code> is
exactly what it is. We don&#39;t have to create two separate classes, instead we
just create an ADT and say that a Tree is either a <code>Node</code> with an element and
two other <code>Trees</code> or it&#39;s <code>Empty</code>. Nothing more and nothing less. The function
to insert an element is equally concise, if the <code>Tree</code> is <code>Empty</code> we create a
new <code>Node</code> and if the <code>Tree</code> is a <code>Node</code> we either add it to the left or to the
right.</p>

<p>Seeing this function got me rethinking recursion and it made me realize that
recursion <em>is</em> a valid tool in the programmer&#39;s toolbox, it&#39;s just that in most
languages recursion is an after-thought that often leads to the stack being
blown.</p>

<p>I still shudder when I see iterative code to manipulate Trees.</p>

<h2>The Language Might Be Ugly</h2>

<h3>Tail Call Optimization</h3>

<p>So if recursion is a valid tool, why isn&#39;t it used more? I know one of the main
reasons that I avoid recursion is because of the stack.</p>

<p>Let&#39;s take the familiar factorial function. In Java, we could write</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>But we&#39;re limited to a certain <code>n</code> since the stack will eventually run out of
space. For the factorial function, the stack space that is required is linear
to <code>n</code>. Since we have to maintain the previous calls in order to complete the
function, the stack continues to grow and grow until BAM! the stack is blown. In
Java you get a <code>StackOverflowError</code>, in C you get a <code>SIGSEGV</code> error (at least on
OS X) and in Python you get a nice <code>RuntimeError: maximum recursion depth error</code>
message. However in a language that embraces recursion, what could we do?</p>

<p>In Scala we could translate the code directly and write</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>But we&#39;re limited by the same thing. Since Scala is a JVM language it&#39;s bounded
by stack space as well, but unlike Java, Scala has support for
<a href="http://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail-call optimization</a>
so instead of simply translating the Java code, we could re-write
it to take advantage of tail-call optimization.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">loop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">loop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">acc</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">loop</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>This version of factorial <em>is</em> tail-recursive. So it uses constant stack space.
Instead of the factorial function evaluating like it did in the example at the
beginning of this article, it now evaluates like this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">factorial</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">loop</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">loop</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">loop</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">loop</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">60</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">loop</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">120</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">120</span>
</span></code></pre></td></tr></table></div></figure>

<p>Instead of <code>loop</code> building on the stack, the previous call can be replaced since
the variables from the previous call don&#39;t have to be maintained. Tail call
optimization can transform recursive functions to tight <code>while</code> loops that don&#39;t
require extra space and since it&#39;s just a loop, there&#39;s no need for the
&#39;unwinding&#39; that usually accompanies recursive functions. Scala also supports
the
<a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.tailrec">@tailrec</a>
annotation enabling the compiler to verify that the function is
indeed tail recursive. If it&#39;s not, the compiler will issue an error before you
even have the chance to blow the stack with what you thought was a
tail-recursive function.</p>

<h4>An Example</h4>

<p>Let&#39;s compare the difference that tail-call optimization makes by comparing two
programs. They both compute the factorial of a number.</p>

<p>The first one is in Java, and here&#39;s the code</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.math.BigInteger</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">factorialIter</span><span class="o">(</span><span class="mi">17000</span><span class="o">).</span><span class="na">toString</span><span class="o">().</span><span class="na">length</span><span class="o">());</span>
</span><span class='line'>        <span class="c1">// the stack is blown here</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="mi">17000</span><span class="o">).</span><span class="na">toString</span><span class="o">().</span><span class="na">length</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">BigInteger</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="na">multiply</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">BigInteger</span> <span class="nf">factorialIter</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">BigInteger</span> <span class="n">res</span> <span class="o">=</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>factorial</code> blows the stack when trying to compute <code>17000!</code> while
<code>factorialIter</code> does just fine. The result is huge, being a number with 64,538
digits.</p>

<p>The second is in Scala</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.math.BigInt</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@tailrec</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">loop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">loop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">acc</span><span class="o">)</span>
</span><span class='line'>  <span class="n">loop</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="mi">17000</span><span class="o">).</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>This version happily computes <code>17000!</code> so let&#39;s try to push it a little bit.</p>

<p>Calling <code>factorial(100000)</code> says that the resulting number has 45,654 digits.</p>

<p><code>factorial(200000)</code> results in a number with 973,351 digits.</p>

<p>And finally, <code>factorial(1000000)</code> results in a number with 5,565,709 digits.
After <strong>some</strong> time of course.</p>

<p>Tail-call optimization is the most important thing that a language could offer
to make using recursive functions more pleasant. The second most important
thing?</p>

<h3>Syntax</h3>

<p>I know syntax isn&#39;t the most important thing to consider when deciding what
language to use, but it definitely plays a role. As an example, consider the
difference between the Java and the Haskell implementation for Trees. They both
accomplish the <em>same</em> thing: construction and insertion, but the Java version is
easily five times longer. But this isn&#39;t necessary a problem with Java, rather
it&#39;s a positive of Haskell.</p>

<p>Haskell and other functional languages are simply built with recursion in mind.
Combined with ADTs where you could much more easily express recursive structures
and the ability to define inner functions, writing recursive functions in these
languages is simply easier and cleaner. In Java you have to pollute the
namespace with &quot;helper&quot; functions, while in a functional language you can simply
define the &quot;helper&quot; function as an inner function or avoid it all together.
Theoretically, <em>if</em> Java supported tail-call optimization, the factorial
function would be something similar to this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">public</span> <span class="nc">BigInteger</span> <span class="n">factorial</span><span class="o">(</span><span class="n">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="nc">BigInteger</span> <span class="n">factorial</span><span class="o">(</span><span class="n">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">BigInteger</span> <span class="n">acc</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">acc</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">acc</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>The problem with this is that the private <code>factorial</code> function will <strong>never</strong> be
used outside of the public <code>factorial</code>, yet there it is, at the top-level,
available for other functions in the same file to call erroneously.</p>

<p>Finally Algebraic Data Types similarly make recursive code cleaner because it
lets you define recursive data structures cleaner. Classes in Java or Python are
sometimes too clunky to use when all you need is a simple representation.
Consider the definition of a Tree</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">data</span> <span class="nc">Tree</span> <span class="n">a</span> <span class="k">=</span> <span class="nc">Node</span> <span class="n">a</span> <span class="o">(</span><span class="nc">Tree</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="nc">Tree</span> <span class="n">a</span><span class="o">)</span> <span class="o">|</span> <span class="nc">Empty</span>
</span></code></pre></td></tr></table></div></figure>

<p>It captures the nature of a Tree without overwhelming you with extraneous
methods or clunky getters and setters. ADTs aren&#39;t the answer all the time, but
being able to reach for them when a class will simply be heavy-handed is
helpful.</p>

<h2>Conclusion</h2>

<p>Recursion has a bad name for a lot of programmers, often being seen as not
practical or too expensive to actually use, but the truth is that recursion is a
great tool to have in your toolbox. It&#39;s not a panacea and it&#39;s not always
better than a loop, but some functions are naturally recursive so writing these
functions iteratively would not only be messy but also a much greater task.
Loops are fine for indexing into an array, but if you have a recursive data
structure such as a List, iterating through the List using recursion makes a lot
more sense.</p>

<p>To transform an array, this makes sense</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>But with a List, this makes more sense</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</span><span class='line'><span class="nf">map</span> <span class="n">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">map</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>

<p>The way you approach a data structure should be defined by it&#39;s nature. You
shouldn&#39;t try to approach a tree iteratively just like you shouldn&#39;t try to
index into a list and treat it like an array. The problem with this is that the
more common languages don&#39;t have good support for recursion so a lot of
programmers could be left thinking that recursion is more-or-less a novelty.</p>

<p>I didn&#39;t appreciate recursion until I had no choice but to actually use it.
After actually using it, I started to appreciate recursion for it&#39;s simplicity
and it&#39;s strength, it was only after I took the
<a href="https://www.cs.berkeley.edu/%7Ebh/pdf/v1ch08.pdf">leap of faith</a>
that I realized how clear and elegant recursion can be. So before thinking that
recursion is the problem, think about the language first. It might be the
language that is ugly and not recursion itself.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Vincent</span></span>

      




<time class='entry-date' datetime='2015-07-26T14:20:48-05:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:20 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://vandrada.github.io/blog/2015/07/26/recursion-is-beautiful/" data-via="" data-counturl="http://vandrada.github.io/blog/2015/07/26/recursion-is-beautiful/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/07/25/lessons-from-haskell-part-1/" title="Previous Post: Lessons From Haskell Part 1">&laquo; Lessons From Haskell Part 1</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/10/04/the-hof-of-hof/" title="Next Post: The HOF of HOF">The HOF of HOF &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/11/list-comprehensions/">List Comprehensions</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/the-hof-of-hof/">The HOF of HOF</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/26/recursion-is-beautiful/">Recursion Is Beautiful, the Language Might Be Ugly</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/25/lessons-from-haskell-part-1/">Lessons From Haskell Part 1</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/vandrada">@vandrada</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'vandrada',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
  <h1>About Me</h1>
  <p> I'm Vincent, a recent graduate from <a href="http://www.utsa.edu">UTSA</a>.</p>
  <p> This blog will be filled with things that I find interesting. At the
    moment, that's primarily functional programming and looking back at the work
    I did during my time as a student. </p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Vincent -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
