
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>The HOF of HOF - Common Code</title>
  <meta name="author" content="Vincent">

  
  <meta name="description" content="One of the first things that could strike fear into anyone who wants to learn
functional programming that comes from an imperative background is the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://vandrada.github.io/blog/2015/10/04/the-hof-of-hof/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Common Code" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Common Code</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="vandrada.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">The HOF of HOF</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-04T13:15:04-05:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:15 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>One of the first things that could strike fear into anyone who wants to learn
functional programming that comes from an imperative background is the lack of
loops. Languages like
<a href="https://ocaml.org/learn/tutorials/if_statements_loops_and_recursion.html#Forloopsandwhileloops">OCaml</a>
supports the familiar for-loop
and
<a href="https://clojuredocs.org/clojure.core/loop">Clojure</a>
kind of supports for-loops, but
these are seen more as escape hatches and aren&#39;t considered &#39;pure&#39;. They are
nice for the convenience and the familiarity of them, but a higher order
function would be better to use in a functional language and there are a couple
of basic ones at your disposal: <code>map</code>, <code>fold</code>, and <code>filter</code> (or variations
thereof for certain languages). Using these in place of for-loops not only
results in cleaner code, but also forces you to think about what you plan on
doing with your for-loop in any language. Each of these functions has a
particular use, so let&#39;s enter <strong>The Hall of Fame of Higher-Order Functions</strong>
and see them one at a time.</p>

<h2>First Attraction: Map</h2>

<p><img src="http://reactivex.io/documentation/operators/images/map.png" alt="">
<code>map</code> transforms a collection by applying a function to each element. <code>map</code>
essentially replaces something like this in Java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>with this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">map</span> <span class="p">(</span><span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="n">arr</span>
</span></code></pre></td></tr></table></div></figure>

<p>It&#39;s Haskell specific signature is <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> which can be
translated to: <code>map</code> takes a function that takes <code>a</code>s as input and produces
<code>b</code>s, a list of <code>a</code>s and finally produces a list of <code>b</code>s. While that&#39;s kind of
awkward to try to distill in English. Some examples definitely help.</p>

<p>Assuming you have a list of <code>Int</code>s and you want a list of <code>String</code>s, you can
convert the while list with this simple one-liner</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">map</span> <span class="n">show</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1">-- [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span>
</span></code></pre></td></tr></table></div></figure>

<p>Want to convert a <code>String</code> to all upper case? Map can do that too</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">map</span> <span class="n">toUpper</span> <span class="s">&quot;hola mundo&quot;</span>
</span></code></pre></td></tr></table></div></figure>

<p>which results in the <code>String</code> &quot;HOLA MUNDO&quot;</p>

<h2>Second Attraction: Filter</h2>

<p><img src="http://reactivex.io/documentation/operators/images/filter.png" alt="">
<code>filter</code> lives up to it&#39;s name and filters elements from a list. <code>filter</code>
applies a predicate to each element in the lists and only keeps those elements
if the predicate is true for that element. The Haskell-specific signature for
<code>filter</code> is <code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>. Skipping the verbosity of a
translated description, let&#39;s go straight to some examples.</p>

<p>Removing odd elements from a list becomes ridiculously easy</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">filter</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>

<p>While that example is straight-forward, <code>filter</code> could be used for more complex
things. Let&#39;s say for some peculiar reason you use <code>ghci</code> as your grocery list
and you want to remove elements that you think are too expensive.  We could
code this up in Haskell and use <code>filter</code> to remove items that cost more than
$3.00</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Product</span> <span class="ow">=</span> <span class="kt">Product</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">name</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">price</span> <span class="ow">::</span> <span class="kt">Float</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nf">ps</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Product</span> <span class="s">&quot;Milk&quot;</span> <span class="mf">2.34</span><span class="p">,</span> <span class="kt">Product</span> <span class="s">&quot;Eggs&quot;</span> <span class="mf">3.45</span><span class="p">,</span> <span class="kt">Product</span> <span class="s">&quot;Bread&quot;</span> <span class="mf">2.20</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="nf">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">p</span> <span class="ow">-&gt;</span> <span class="n">price</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mf">3.00</span><span class="p">)</span> <span class="n">ps</span>
</span></code></pre></td></tr></table></div></figure>

<p>which is far more succinct--and explicit--than something along the lines of</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">price</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">float</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// getters and setters...</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Product</span> <span class="n">ps</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="o">[]{</span><span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="s">&quot;Milk&quot;</span><span class="o">,</span> <span class="mf">2.34</span><span class="o">),</span> <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="s">&quot;Eggs&quot;</span><span class="o">,</span>
</span><span class='line'>        <span class="mf">3.45</span><span class="o">),</span> <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="s">&quot;Bread&quot;</span><span class="o">,</span> <span class="mf">2.20</span><span class="o">)};</span>
</span><span class='line'>
</span><span class='line'><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">cheapProducts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;();</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ps</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">ps</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">cheapProducts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ps</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2>Our Final Attraction: Fold</h2>

<p style="text-align:center;">
<img src="https://wiki.haskell.org/wikiupload/5/5a/Left-fold-transformation.png">
</p>

<p style="text-align:center;">
<img src="https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png">
</p>

<p><code>fold</code> is <em>the</em> higher-order recursive function. <code>map</code> and <code>filter</code> can be
expressed in terms of fold. In The HOF of HOF <code>fold</code> is the GOAT. <code>fold</code> is
complex at first, but once you get a hold of it, you&#39;ll see that it can be
applied to so many different areas. So if <code>map</code> is for transforming elements
and <code>filter</code> is for removing elements, what&#39;s the purpose of <code>fold</code>? Well,
<code>fold</code> is for reducing a collection of values to a single value, which explains
why <code>fold</code> is also known as <code>reduce</code> or <code>aggregate</code> in so many other languages.</p>

<p>Haskell has two primary <code>fold</code> functions. <code>foldr</code> starts from the right end of
the list, and <code>foldl</code> starts at the left-end of the list. When you&#39;re using an
associative function, the difference isn&#39;t all that important, but once you
start using functions that aren&#39;t associative like subtraction, the difference
is appearant. For some reason, I had a hard time remembering the difference
between <code>foldl</code> and <code>foldr</code>, in order to remember them, I had to think about
where the parentheses end up being grouped together.  I&#39;m getting a little
ahead of myself, so time to show the signature and some examples.</p>

<p>Since Haskell doesn&#39;t have a generic <code>fold</code> function, I&#39;m going to use <code>foldl</code>
since it has the most analogues in other languages. The signature for <code>foldl</code> is
<code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>. This function would be really verbose
to translate, so to the examples we go.</p>

<p>The sum of a list can be expressed in terms of <code>fold</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">foldl</span> <span class="o">(+)</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>

<p>and so can the product</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">foldl</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>

<p>But a brief walk through is in order since <code>foldl</code> is really the most
complicated of the three functions.</p>

<h3>Walk Through</h3>

<p>Let&#39;s take the sum example and dissect it step-by-step.</p>

<p>The initial call is <code>foldl (+) 0 [1, 2, 3, 4, 5]</code></p>

<p>The first argument is the function to use to reduce the list and the second
argument is the initial value to use. Eventually, summing a list with <code>foldl</code>
results in something along the lines of</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(((((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>But it uses the structure of recursive lists to accomplish this.</p>

<p>We can write an un-optimized <code>fold</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fold</span> <span class="n">f</span> <span class="n">acc</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">acc</span>
</span><span class='line'><span class="nf">fold</span> <span class="n">f</span> <span class="n">acc</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fold</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">acc</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure>

<p>and use it throughout this example.</p>

<p>Ok, so with the initial call to <code>fold</code> we follow through the second function
definition since the list isn&#39;t empty. If we expand the function we get</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fold</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>

<p>In the first reduction, the initial value is simply added to the initial
accumulator and the list is reduced and now has one less element.</p>

<p>The second call would expand to <code>fold (+) 1 [2, 3, 4, 5]</code> so once again we use
the second definition and the recursive call would be</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fold</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>

<p>we do much the same thing with 3, 4, 5, and it&#39;s not until the end of the list
that we reach the first definition of <code>fold</code>. Since the list is now empty and
we&#39;ve accumulated all the values, the only thing we need to do is return the
accumulated value, which in this example is 15.</p>

<p>This is a high-level overview of <code>fold</code> and the truth is that the magic happens
in the function that is passed to <code>fold</code>, so instead of using the shortcut of
<code>(+)</code>, let&#39;s expand it to a proper lambda. <code>(+)</code> could be expanded to
<code>\x y -&gt; x + y</code>, and for this particular example, let&#39;s give the variables some
meaningful names. If we give the variables better names, we get
<code>\acc x -&gt; acc + x</code>.</p>

<p>Now that we&#39;ve expanded the function used to reduce the list, let&#39;s walk through
the example again, giving explicit values to <code>acc</code> and <code>x</code>.</p>

<p>The initial call is <code>fold (\acc x -&gt; acc + x) 0 [1, 2, 3, 4, 5]</code>.</p>

<p>And here&#39;s a table to show what happens at each step</p>

<table style="width:40%" border="1">
    <tr>
        <th> List </th>
        <th> acc </th>
        <th> x </th>
    </tr>
    <tr>
        <td> [2, 3, 4, 5] </td>
        <td> 0 </td>
        <td> 1 </td>
    </tr>
    <tr>
        <td> [3, 4, 5] </td>
        <td> 1 </td>
        <td> 2 </td>
    </tr>
    <tr>
        <td> [4, 5] </td>
        <td> 3 </td>
        <td> 3 </td>
    </tr>
    <tr>
        <td> [5] </td>
        <td> 6 </td>
        <td> 4 </td>
    </tr>
    <tr>
        <td> [] </td>
        <td> 10 </td>
        <td> 5 </td>
    </tr>
</table>

<p><br></p>

<p>At this point, all there is to do is add 10 and 5 and return the result which is
15.</p>

<h3>The Expressiveness of fold</h3>

<p>As mentioned earlier, fold is <em>the</em> recursive higher-order function, one of
the reasons for this is that the return type is entirely open-ended. Unlike
<code>map</code> and <code>filter</code> which have to return a list, <code>fold</code> is free to return
anything, as long as it&#39;s the <em>accumulated</em> value for that list. This means that
<code>map</code> could be written in terms of fold and the accumulated value is simply the
original list but with the function applied to each element.</p>

<p>With that in mind, <code>map</code> could be expressed in terms of <code>fold</code> and the folding
function has to accumulate the new list with the function applied.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</span><span class='line'><span class="nf">myMap</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure>

<p>And similarly, <code>filter</code> could be expressed in terms of <code>fold</code> and the
accumulated value is simply a list where the elements satisfy the given
predicate.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myFilter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">myFilter</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">p</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure>

<h2>Tips and Tricks</h2>

<p>As alluded to earlier, I had a hard time when I first encountered <code>fold</code>. It
felt like I was learning loops again, and I think this has to do with the fact
that it&#39;s so general compared to <code>filter</code> and <code>map</code>. You could reduce a list in
so many ways and reduction is open-ended in every case, it could be a single
value or a new collection. While <code>map</code>ing and <code>filter</code>ing have straight-forward
behavior, <code>fold</code>ing and reducing could vary from context to context. As the
previous section shows, <code>fold</code> can be used express a lot of other functions.
To save someone else the ride on <code>fold</code>s learning-curve, I want to share a
couple of things that really helped <code>fold</code> click for me.</p>

<h3>It&#39;s All in the Reducing Function</h3>

<p><code>fold</code> is driven by the reducing function and as such, understanding how the
reducing function applies in different contexts is extremely helpful. So to
illustrate that concept, let&#39;s implement <code>head</code> and <code>last</code> in terms of <code>fold</code>.
<code>head</code> returns the head of a list so <code>head [1, 2, 3, 4, 5]</code> should return <code>1</code>
and <code>last</code> returns the last element in a list so <code>last [1, 2, 3, 4, 5]</code> should
return <code>5</code>. Let implement these functions in terms of <code>fold</code>.</p>

<p>For these particular functions, I&#39;m going to be using a variation of <code>foldl</code>
called <code>foldl1</code>. <code>foldl1</code> is almost the same as <code>foldl</code> except it uses the first
element in the list instead of an explicit initializer. Because of this it has a
simpler signature, which is <code>foldl1 :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</code>.</p>

<p>So how would we write <code>head</code> in terms of <code>foldl1</code>? Well we need to write the
proper function. In this case, the function should simply return the first
element that it sees and ignore everything else. In Haskell, this function
could be written as an anonymous function as <code>(\acc x -&gt; acc)</code> which simply
ignores any other element in the list since it keeps passing the first element
(the accumulated value). With the function defined, we could write <code>head</code> as</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myHead</span> <span class="ow">=</span> <span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">acc</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>With each recursive call, <code>myHead</code> will reduce the list by one element and
discard that element, instead it passes the initializer all the way down the list.
Obviously, this isn&#39;t the most asymptotically efficient function since it has to
iterate through the entirety of the list just to return the first element, but
this shows that it can be done in terms of <code>fold</code>.</p>

<p>Now onto <code>last</code>. If <code>head</code> ignored any subsequent element after the initializer,
<code>last</code> does the exact opposite. It ignores any previously seen elements and just
keeps passing the new value. This function is very similar to the one used for
<code>head</code>: <code>(\acc x -&gt; x)</code>. This lambda reduces the list by one element and keeps
passing the new element until we reach the end. Now we can write our version of
<code>last</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">myLast</span> <span class="ow">=</span> <span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>Finally, the most important thing to remember about the reducing function is
that the order of arguments makes a difference. Conveniently, there&#39;s a simple
mnemonic device to remember it. When using <code>foldl</code> the accumulator should be on
the left side so the lambda should follow something like <code>\acc x -&gt; ...</code> and
with <code>foldr</code> the accumulator should be on the right side like <code>\x acc -&gt; ...</code>.</p>

<h3>One Last Example</h3>

<p>So finally, for the last example we&#39;ll write a simple function that reads a
<code>String</code> and converts it to an <code>Int</code>. We&#39;ll use <code>fold</code> to traverse the <code>String</code>
and the reducing function will handle building up the final value. The first
thing we need to decide is which <code>fold</code> to use. Since we need to traverse the
<code>String</code> from the beginning of the list, we should use <code>foldl</code>. With that out of
the way, we can move on to the folding function. Since we&#39;re using <code>foldl</code> we
can start off with the following function template <code>\acc x -&gt; ...</code> and we just
need to fill in the rest.</p>

<p>The function needs to handle reading the <code>Char</code> and converting it to an <code>Int</code>.
Luckily, Haskell has the function <code>digitToInt</code> that resides in the <code>Data.Char</code>
module. <code>digitToInt</code> lives up to its name quite well. The signature is
<code>digitToInt :: Char -&gt; Int</code>, and <code>digitToInt &#39;7&#39;</code> returns <code>7</code> and <code>digitToInt
&#39;2&#39;</code> returns <code>2</code>. <code>digitToInt</code> doesn&#39;t handle <code>String</code>s, but that&#39;s exactly the
function that we are writing! So let&#39;s start calling this function <code>stringToInt</code>.</p>

<p>Ok, so we have reading the <code>Char</code> as an <code>Int</code> and we just need to handle adding
the new digit and multiplying the accumulated value to account for the different
places in the number. Fortunately, we&#39;re using standard base-10 numbers so all
this is ridiculously easy. The folding function is <code>\acc x -&gt; digitToInt x + acc
* 10</code>. Now, we can tie it all together and <code>stringToInt</code> is an awesome
one-liner:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">stringToInt</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">stringToInt</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">digitToInt</span> <span class="n">x</span> <span class="o">+</span> <span class="n">acc</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">0</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure>

<p>So let&#39;s try out a new function, to see if it works</p>

<ul>
<li><p><code>stringToInt &quot;23541&quot;</code> returns <code>23541</code></p></li>
<li><p><code>stringToInt &quot;1&quot;</code> returns <code>1</code></p></li>
<li><p><code>stringToInt &quot;873132&quot;</code> returns <code>873132</code></p></li>
</ul>

<p>The really cool thing about <code>stringToInt</code> is that we could use it as a template
and use it to read binary string or hexadecimal strings. What do we have to
change to read binary strings? Well, instead of multiplying by 10 we just
multiply by 2. <sup>(Ignoring error-checking of course)</sup></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">binaryStringToInt</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">binaryStringToInt</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">digitToInt</span> <span class="n">x</span> <span class="o">+</span> <span class="n">acc</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure>

<p>And since <code>digitToInt</code> also handles hexadecimal digits, all we need to change is
the base to convert hexadecimal strings.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">hexStringToInt</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">hexStringToInt</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">digitToInt</span> <span class="n">x</span> <span class="o">+</span> <span class="n">acc</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="mi">0</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure>

<p>Obviously, there&#39;s a simple pattern here, so let&#39;s take it one step further and
make a function that could read a number in <em>any</em> base (well actually any base
up to 16 since we&#39;re relying on <code>digitToInt</code>) and converts it to an <code>Int</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">baseStringToInt</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">baseStringToInt</span> <span class="n">base</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">digitToInt</span> <span class="n">x</span> <span class="o">+</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>

<p>and we could refactor our previous functions to use it</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">stringToInt</span> <span class="ow">=</span> <span class="n">baseStringToInt</span> <span class="mi">10</span>
</span><span class='line'>
</span><span class='line'><span class="nf">binaryStringToInt</span> <span class="ow">=</span> <span class="n">baseStringToInt</span> <span class="mi">2</span>
</span><span class='line'>
</span><span class='line'><span class="nf">hexStringToInt</span> <span class="ow">=</span> <span class="n">baseStringToInt</span> <span class="mi">16</span>
</span></code></pre></td></tr></table></div></figure>

<h2>Conclusion</h2>

<p>So that&#39;s the brief tour of The HOF of HOF. We saw <code>map</code>, <code>filter</code>, and finally
the GOAT <code>fold</code>. These functions rely on other functions and transform
collections in some particular way. The really great thing about learning these
functions is that they improve your code in any language! I have nothing
against &quot;raw loops&quot;--or loops that use explicit indexes--and understand that
they have their place, but instead of writing loops that do three different
things in the body, it makes code a whole lot cleaner to write a loop that does
one single thing and one thing well. Personally, I used to write for loops with
bodies that were &gt;90 lines and did everything they possibly could. After
learning about <code>map</code>, <code>filter</code>, and <code>fold</code> I now write loop bodies that
accomplish their task and quickly exit.</p>

<p>The body of a loop is a dangerous place, you first have to worry about the
index and not trying to access imaginary elements, and after that you have to
be careful in the actual body and make sure you&#39;re not launching missiles,
creating way more server requests than you need, or <code>free</code>ing a struct twice.
<code>map</code>, <code>filter</code>, and <code>fold</code> help in reducing the risk involved in for-loops.
Unlike raw loops where the body is anything you want it to be, these functions
require functions that you can easily test outside of these recursive functions.
While not every language supports these functions, learning what you want to
accomplish in a loop can help a lot. Maybe for other people this is
common-sense, but for me, it wasn&#39;t until learning <code>map</code>, <code>filter</code>, and <code>fold</code>,
that I started approaching for-loops with a whole lot more discipline. Now, when
I write a for-loop, I&#39;m always aware if I want to remove elements, change
elements, or something more general.</p>

<p>Just like anything else, the functions in The HOF of HOF aren&#39;t a cure-all.
They won&#39;t result in magic code that never fails or performs exactly as you
want. You can still mess up and have your code blow up in your face, but these
functions enforce the thing that every would-be programmer hears in class or
sees in an article somewhere: don&#39;t repeat yourself--use functions. Write
functions to break up behavior and approach your code in a sensible way. Maybe
functional programming is a pain, but ultimately, it forces you to use
higher-level constructs that are just a little bit safer and little bit
clearer.</p>

<p>For-loops have their place and everyone would be lost without them, but
instead of approaching them and just saying &quot;I need to do <em>x</em> this many times,&quot;
think about exactly what you need to do. Do you need to remove elements, change
elements or reduce them in some way? Well, it just so happens that that&#39;s a
pretty common operation and there&#39;s a nice--and safe--way to do that.</p>

<p><em>This marks the end of The Hall of Fame of Higher-Order Functions. Maybe there
will be new inductees in the future, but this marks the end for now. The exits
are to the left and to the right. Thank you for your time.</em></p>

<p><em>... and don&#39;t forget to tip your tour guide</em></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Vincent</span></span>

      




<time class='entry-date' datetime='2015-10-04T13:15:04-05:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:15 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://vandrada.github.io/blog/2015/10/04/the-hof-of-hof/" data-via="" data-counturl="http://vandrada.github.io/blog/2015/10/04/the-hof-of-hof/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/07/26/recursion-is-beautiful/" title="Previous Post: Recursion is Beautiful, The Language Might Be Ugly">&laquo; Recursion is Beautiful, The Language Might Be Ugly</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/10/11/list-comprehensions/" title="Next Post: List Comprehensions">List Comprehensions &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/11/list-comprehensions/">List Comprehensions</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/the-hof-of-hof/">The HOF of HOF</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/26/recursion-is-beautiful/">Recursion Is Beautiful, the Language Might Be Ugly</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/25/lessons-from-haskell-part-1/">Lessons From Haskell Part 1</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/vandrada">@vandrada</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'vandrada',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
  <h1>About Me</h1>
  <p> I'm Vincent, a recent graduate from <a href="http://www.utsa.edu">UTSA</a>.</p>
  <p> This blog will be filled with things that I find interesting. At the
    moment, that's primarily functional programming and looking back at the work
    I did during my time as a student. </p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Vincent -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
